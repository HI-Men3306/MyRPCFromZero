# 遇到的问题

# Question 1

> **在version2阶段，我自己尝试复刻的时候，因为写反了客户端socket获取输入和输出流的顺序，导致一直阻塞在input上**

最后发现的问题，其实并不在我把客户端socket的输入输出流写颠倒了，而是我同时把客户端和服务器的socket的输入输出流都写颠倒了，我把两个socket都设置为了先获取inputstream，再获取outputstream，这样导致的一个问题就是**请求连接上的一个死锁问题**

![截图](截图.png)

造成的原因：

在tcp/ip通信中，数据的通信是双向的，需要有响应的输入输出流才能建立正常的通信，如果只建立了输入流而没有建立输出流，就会导致服务器无法读取客户端消息，客户端也无法读取服务器消息，他们俩都互相等待对方的消息，造成死锁。在Socket编程中，我们首先获取输出流然后再获取输入流的原因在于，我们需要通过输出流向服务端发送请求，只有当这个请求被服务端接收后，服务端才会返回一个响应，这时我们才能通过获取到的输入流读取到服务端的响应。

具体来说，当我们在服务器端创建一个ServerSocket并监听某个端口时，它实际上就是在等待客户端的连接请求。而当客户端向服务器端发送连接请求时，服务器端的accept()方法就会返回一个新的Socket，这个新的Socket就是用来和客户端进行通信的。接着我们就可以在这个新的Socket上创建输入流和输出流了。其中，输出流用于将数据发送给客户端，输入流用于接收来自客户端的数据。所以，我们在获取输入流之前需要先获取输出流。

**我的理解**

> 我理解的意思是就像通信双发获取输入输出流阶段就像是tcp建立连接时一样，都需要一方先发送连接请求，才能完成后续的连接建立，但是因为我设置的两方都是先等对方发送连接请求，所以造成他们俩都一直在互相等对面发送连接请求